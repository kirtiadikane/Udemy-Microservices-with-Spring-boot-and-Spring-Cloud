Step  - Spring Cloud API Gateway
-------------------------------------------------------------------------
Initial

- http://localhost:8765/CURRENCY-EXCHANGE/currency-exchange/from/USD/to/INR

- http://localhost:8765/CURRENCY-CONVERSION/currency-conversion/from/USD/to/INR/quantity/10

- http://localhost:8765/CURRENCY-CONVERSION/currency-conversion-feign/from/USD/to/INR/quantity/10



Lower Case

- http://localhost:8765/currency-exchange/currency-exchange/from/USD/to/INR

- http://localhost:8765/currency-conversion/currency-conversion/from/USD/to/INR/quantity/10

- http://localhost:8765/currency-conversion/currency-conversion-feign/from/USD/to/INR/quantity/10


************************************************************
Step 24: Exploring Routes with Spring Cloud Gateway
------------------------------------------------------------
http://localhost:8765/get


Custom Routes

- http://localhost:8765/currency-exchange/from/USD/to/INR

- http://localhost:8765/currency-conversion/from/USD/to/INR/quantity/10

- http://localhost:8765/currency-conversion-feign/from/USD/to/INR/quantity/10

- http://localhost:8765/currency-conversion-feign-new/from/USD/to/INR/quantity/10


------------------------------------------------------------------------------------------------------
Step 25 - Implementing Spring Cloud Gateway Logging Filter
Spring Cloud gateway is an awesome way to route to your APIs and implement your crosscutting concerns. Things like security, monitoring, metrics, 
these are the best things that you can implement in a Spring Cloud gateway. This is built on top of Spring WebFlux, and that's the reason why we needed to use the reactive approach.
Some of the important features of Spring Cloud Gateway are it can match request on any request attribute.


------------------------------------------------------------------------------------------------------
Step 26 - Getting started with Circuit Breaker - Resilience4j

we have talked about the fact that in a microservices architecture there is a complex call chain. As shown in the example here, a microservice can call another microservice.
That microservice might be dependent on another microservice and so on and so forth. And what would happen if one of these services is down or is very slow? Let's say microservice 
four is down or it's very, very slow. What would happen? There would be an impact on the entire chain. If the microservice four is down, then microservice three also will be down,
microservice two also will be down, because these are all depending on microservice 4. Even if it's slow, then there is a corresponding impact on the other microservices too. In 
these microservices, there will be a buildup of calls because this microservice is slow. All these chains also get impacted.
So the questions are, can we return a fallback response if a service is down?
If I see that the microservice four is down, in the microservice three, can I return a fallback response? Can I configure a default response? This might not always be possible.
For example, in the case of a credit card transaction, or something of that kind, you do not have any fallback responses possible. But in the case of a shopping application, instead 
of returning a set of products you might return a default set of products. That's possible. The other question to consider is can we implement a circuit breaker pattern to reduce 
the load? If I see that microservice four is down, instead of repeatedly hitting it and causing it to go down, can I actually return the default response back without even hitting
the microservice? 

The other question to consider is, can we retry requests in case of temporary failures? If there is a temporary failure from a microservice four, can I retry it a few times
and only when it has failed multiple times, I return a default response back.
The last question is, can we implement something like rate limiting?
I want to allow only certain number of calls to a specific microservice in a specific period of time.
If you're using Spring Boot, then there is a circuit breaker framework which is available, which is called Resilience4j.
Resilience4j is a lightweight, easy to use, fault tolerant library inspired by Netflix Hystrix. In the previous versions of Spring Boot and Spring Cloud, Netflix Hystrix was the 
recommended circuit breaker framework. However, with the evolution of Java eight and functional programming, Resilience4j has become the recommended framework.

You can integrate Resilience4j with Spring Boot, the first thing that we need to do is to add the dependencies on Resilience4j Spring Boot 2, Spring Boot starter actuator and Spring Boot starter AOP.


------------------------------------------------------------------------------------------------------
Step 28 - Playing with Circuit Breaker Features of Resilience4j

A circuit breaker can be in three different states, closed, open, and half open.
What are the different states?
Closed is when I am calling the dependent microservice continuously. So in a closed state I'll always be calling the dependent microservice.
In a open state, the circuit breaker will not call the dependent microservice. It'll directly return the fallback response.
And in a half open state, a circuit secure breaker would be sending a percentage of requests to the dependent microservice,
and for rest of the requests, it would return the hard coded response or the fallback response back.

When does the circuit secure breaker switch from one state to another?
For example, the circuit breaker is in the closed state. When you start the application up the circuit breaker is typically in a closed state. Let's say I'm calling the dependent microservice
10,000 times and I see that all of them are failing or I see that 90% of them are failing. In that kind of scenario, the circuit breaker would switch to a open state. Once it switches through 
an open state it waits for a little while. It, there's a wait duration that you can configure. After that wait duration the circuit breaker would switch to a half open state. During the half 
open state. The circuit breaker would try and see if the dependent microservice is up. So it sends a percentage of the request. You can configure how much percentage. It would send let's say 
10% or 20% of the request to the dependent microservice. And if it gets proper responses for that then it would go back to the closed state. If it does not get proper responses, then it would 
go back to the open state.

documentation- https://resilience4j.readme.io/docs/circuitbreaker



------------------------------------------------------------------------------------------------------
Section 7: Docker with Microservices using Spring Boot and Spring Cloud - V2
------------------------------------------------------------------------------------------------------
Step 00 - Match made in Heaven - Docker and Microservices

We have talked about the fact that enterprises are heading towards microservices architectures. You're building a number of small microservices that communicate with each 
other, and help you to achieve your required functionality. As part of our microservices architectures, we build a number of small focused microservices. One of the biggest 
advantages of microservices, is the flexibility to innovate and build applications in different programming languages. You can build microservices using Java and Spring Boot, 
as we are doing in this specific course. You can also build microservices using Go, Python, JavaScript, and a variety of other programming languages. But as we start exploring 
the microservices architecture, and start implementing different languages, the deployments of these microservices become complex. Let's say the movie microservice and the 
customer microservice are implemented in Java, and let's say the other ones are implemented in Python. You do not want different deployment procedures for each of these 
microservice types. How can you get a common way to deploy multiple microservices irrespective of the language, or the framework that is used to build these microservices? 
How can we get one way of deploying Go, Java, Python, or JavaScript microservices? That's where containers come into picture, and the most popular container tool is Docker. 
What you can do is to create Docker images for each of these microservices. So for all the microservices that we looked over here, you can create Docker images. 
The Docker image contains everything that a microservice needs to run. The Application Runtime, JDK, Python, or NodeJS. The application code for Java applications. It might 
just be the JAR, your dependencies that you need to run the application. So, everything is part of your Docker image, and once you have this Docker image, you can run these 
as docker containers the same way on any infrastructure. So you can run these Docker images on your local machine in a corporate data center, and also in the Cloud, whether 
it's AWS, Azure, or Google Cloud. All of these support running docker containers in a wide variety of ways.


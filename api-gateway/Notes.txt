Step  - Spring Cloud API Gateway
-------------------------------------------------------------------------
Initial

- http://localhost:8765/CURRENCY-EXCHANGE/currency-exchange/from/USD/to/INR

- http://localhost:8765/CURRENCY-CONVERSION/currency-conversion/from/USD/to/INR/quantity/10

- http://localhost:8765/CURRENCY-CONVERSION/currency-conversion-feign/from/USD/to/INR/quantity/10



Lower Case

- http://localhost:8765/currency-exchange/currency-exchange/from/USD/to/INR

- http://localhost:8765/currency-conversion/currency-conversion/from/USD/to/INR/quantity/10

- http://localhost:8765/currency-conversion/currency-conversion-feign/from/USD/to/INR/quantity/10


************************************************************
Step 24: Exploring Routes with Spring Cloud Gateway
------------------------------------------------------------
http://localhost:8765/get


Custom Routes

- http://localhost:8765/currency-exchange/from/USD/to/INR

- http://localhost:8765/currency-conversion/from/USD/to/INR/quantity/10

- http://localhost:8765/currency-conversion-feign/from/USD/to/INR/quantity/10

- http://localhost:8765/currency-conversion-feign-new/from/USD/to/INR/quantity/10


------------------------------------------------------------------------------------------------------
Step 25 - Implementing Spring Cloud Gateway Logging Filter
Spring Cloud gateway is an awesome way to route to your APIs and implement your crosscutting concerns. Things like security, monitoring, metrics, 
these are the best things that you can implement in a Spring Cloud gateway. This is built on top of Spring WebFlux, and that's the reason why we needed to use the reactive approach.
Some of the important features of Spring Cloud Gateway are it can match request on any request attribute.


------------------------------------------------------------------------------------------------------
Step 26 - Getting started with Circuit Breaker - Resilience4j

we have talked about the fact that in a microservices architecture there is a complex call chain. As shown in the example here, a microservice can call another microservice.
That microservice might be dependent on another microservice and so on and so forth. And what would happen if one of these services is down or is very slow? Let's say microservice 
four is down or it's very, very slow. What would happen? There would be an impact on the entire chain. If the microservice four is down, then microservice three also will be down,
microservice two also will be down, because these are all depending on microservice 4. Even if it's slow, then there is a corresponding impact on the other microservices too. In 
these microservices, there will be a buildup of calls because this microservice is slow. All these chains also get impacted.
So the questions are, can we return a fallback response if a service is down?
If I see that the microservice four is down, in the microservice three, can I return a fallback response? Can I configure a default response? This might not always be possible.
For example, in the case of a credit card transaction, or something of that kind, you do not have any fallback responses possible. But in the case of a shopping application, instead 
of returning a set of products you might return a default set of products. That's possible. The other question to consider is can we implement a circuit breaker pattern to reduce 
the load? If I see that microservice four is down, instead of repeatedly hitting it and causing it to go down, can I actually return the default response back without even hitting
the microservice? 

The other question to consider is, can we retry requests in case of temporary failures? If there is a temporary failure from a microservice four, can I retry it a few times
and only when it has failed multiple times, I return a default response back.
The last question is, can we implement something like rate limiting?
I want to allow only certain number of calls to a specific microservice in a specific period of time.
If you're using Spring Boot, then there is a circuit breaker framework which is available, which is called Resilience4j.
Resilience4j is a lightweight, easy to use, fault tolerant library inspired by Netflix Hystrix. In the previous versions of Spring Boot and Spring Cloud, Netflix Hystrix was the 
recommended circuit breaker framework. However, with the evolution of Java eight and functional programming, Resilience4j has become the recommended framework.

You can integrate Resilience4j with Spring Boot, the first thing that we need to do is to add the dependencies on Resilience4j Spring Boot 2, Spring Boot starter actuator and Spring Boot starter AOP.


------------------------------------------------------------------------------------------------------
Step 28 - Playing with Circuit Breaker Features of Resilience4j

A circuit breaker can be in three different states, closed, open, and half open.
What are the different states?
Closed is when I am calling the dependent microservice continuously. So in a closed state I'll always be calling the dependent microservice.
In a open state, the circuit breaker will not call the dependent microservice. It'll directly return the fallback response.
And in a half open state, a circuit secure breaker would be sending a percentage of requests to the dependent microservice,
and for rest of the requests, it would return the hard coded response or the fallback response back.

When does the circuit secure breaker switch from one state to another?
For example, the circuit breaker is in the closed state. When you start the application up the circuit breaker is typically in a closed state. Let's say I'm calling the dependent microservice
10,000 times and I see that all of them are failing or I see that 90% of them are failing. In that kind of scenario, the circuit breaker would switch to a open state. Once it switches through 
an open state it waits for a little while. It, there's a wait duration that you can configure. After that wait duration the circuit breaker would switch to a half open state. During the half 
open state. The circuit breaker would try and see if the dependent microservice is up. So it sends a percentage of the request. You can configure how much percentage. It would send let's say 
10% or 20% of the request to the dependent microservice. And if it gets proper responses for that then it would go back to the closed state. If it does not get proper responses, then it would 
go back to the open state.

documentation- https://resilience4j.readme.io/docs/circuitbreaker